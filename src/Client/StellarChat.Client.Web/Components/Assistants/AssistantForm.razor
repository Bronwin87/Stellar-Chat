@inject NavigationManager _navigationManager
@inject IAssistantService _assistantService
@inject IStorageService _storageService
@inject IAvailableModelsService _availableModelsService

<EditForm Model="@Assistant" OnValidSubmit="OnValidSubmit">
    <DataAnnotationsValidator />
    <div class="d-flex flex-column flex-grow-1 gap-3 pa-4">
        <MudText>Name</MudText>
        <MudTextField @bind-Value="Assistant!.Name" Variant="Variant.Outlined" Margin="Margin.Dense" For="@(() => Assistant!.Name)" />

        <MudText>Description</MudText>
        <MudTextField @bind-Value="Assistant!.Description" Variant="Variant.Outlined" Margin="Margin.Dense" For="@(() => Assistant!.Description)" />

        <MudText>Avatar</MudText>
        <AvatarUpload ImageUrl="@Assistant.AvatarUrl" OnInputFileChanged="OnInputFileChanged" />
        
        <MudText>Model</MudText>
        <MudSelect @bind-Value="Assistant.DefaultModel" Margin="Margin.Dense" T="string" Variant="Variant.Outlined" For="@(() => Assistant!.DefaultModel)">
            @foreach (var model in AvailableModels)
            {
                <MudSelectItem Value="@model.Name" />
            }
        </MudSelect>

        <MudText>Metaprompt</MudText>
        <MudTextField @bind-Value="Assistant!.Metaprompt" 
                      T="string" Variant="Variant.Outlined" 
                      AutoGrow 
                      Lines="7" 
                      MaxLines="10" 
                      Margin="Margin.Dense" 
                      HelperText="@assistantBehaviorGuidelines" 
                      For="@(() => Assistant!.Metaprompt)" />
    </div>
    <div class="d-flex flex-row flex-grow-1 justify-end gap-4 pa-4">
        <MudButton ButtonType="ButtonType.Submit" Variant="Variant.Filled" Color="Color.Primary" Class="ml-auto">Save</MudButton>
    </div>
</EditForm>

@code 
{
    [Parameter] public Guid AssistantId { get; set; }
    [Parameter] public EventCallback OnAssistantSubmit { get; set; }
    private AssistantResponse Assistant { get; set; } = new();
    private List<AvailableModelsResponse> AvailableModels { get; set; } = new();

    private const string assistantBehaviorGuidelines = @"
Enter the Metaprompt here. This set of instructions will define your assistant's behavior
in every conversation, guiding how it interacts and responds. Keep it concise, clear, and
reflective of the assistant's intended personality and capabilities.";

    private const string DefaultAvatarUrl = "https://th.bing.com/th/id/OIG3.PYK1.ctv1ceJsoR9RZxZ?w=270&h=270&c=6&r=0&o=5&dpr=1.1&pid=ImgGn";

    private bool success;

    protected override async Task OnInitializedAsync()
    {
        await LoadModels();
    }

    protected async override Task OnParametersSetAsync()
    {
        await PopulateForm();
    }

    private async void OnValidSubmit(EditContext context)
    {
        if (AssistantId != Guid.Empty)
        {
            await UpdateAssistantAsync(Assistant!);
        }
        else
        {
            await CreateAssistantAsync();
        }

        success = true;
        await OnAssistantSubmit.InvokeAsync();
        StateHasChanged();
    }

    private async Task PopulateForm()
    {
        if (Guid.Empty != AssistantId)
        {
            await FetchAssistantToUpdate();
        }
        else
        {
            SetupNewAssistantParameters();
        }
    }

    private async Task LoadModels()
    {
        var models = await _availableModelsService.BrowseAvailableModels();

        if (models is not null)
        {
            // TODO: Temporary solution - Filter models on the backend to include only 'gpt' family in the future
            // This is a temporary workaround. Implement backend filtering to include only models belonging to the 'gpt' family in the future.

            AvailableModels = models.Where(model => model.Name.StartsWith("gpt", StringComparison.InvariantCultureIgnoreCase)).ToList();
        }
    }

    private async Task FetchAssistantToUpdate()
    {
        var assistant = await _assistantService.GetAssistant(AssistantId);

        if (assistant is not null)
        {
            Assistant = new AssistantResponse
            {
                Id = assistant.Id,
                Name = assistant.Name,
                Metaprompt = assistant.Metaprompt,
                Description = assistant.Description,
                // TODO: temp solution
                AvatarUrl = assistant.AvatarUrl ?? DefaultAvatarUrl,
                DefaultModel = assistant.DefaultModel,
                DefaultVoice = assistant.DefaultVoice,
                IsDefault = assistant.IsDefault,
                CreatedAt = assistant.CreatedAt,
                UpdatedAt = assistant.UpdatedAt
            };
        }
    }

    private void SetupNewAssistantParameters()
    {
        // TODO: temp solution
        Assistant!.AvatarUrl = DefaultAvatarUrl;
        Assistant.IsDefault = false;
    }

    private async Task CreateAssistantAsync()
    {
        if (Assistant is not null)
        {
            await _assistantService.CreateAssistant(Assistant);
        }
    }

    private async Task UpdateAssistantAsync(AssistantResponse assistant)
    {
        if (assistant is not null)
        {
            await _assistantService.UpdateAssistant(assistant);
        }
    }

    private async Task OnInputFileChanged(InputFileChangeEventArgs e)
    {
        var file = e.File;

        if (file is not null)
        {
            var response = await _storageService.UploadFileAsync(file, "avatar");
            Assistant.AvatarUrl = response.Url;
        }
    }
}
